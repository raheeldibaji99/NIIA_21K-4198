# -*- coding: utf-8 -*-
"""ABC_Algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Btrlc7vimMPwhz4Gz4tex0rU0s38xkPg
"""

# Import Libraries
import math
import random
import numpy as np
import datetime
import time
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd

# -------------------------------------------------------------------------------------------------------------------------------------


# Uncomment the performance measure which you want to computer and make sure to comment out other three

from accuracy import Model
# from precision import Model
# from recall import Model
# from f1_score import Model

# ----------------------------------------------------------------------------------------------------------------------





# 1- Find Objective function value for each solution in population

def ObjectiveValue(sol):

  result = Model(sol)
  return result



# 2- Find Fitness Value for every solution using objective function values

def FitnessValue(obj_val):

  if obj_val >= 0:
    fit_val = obj_val
  else:
    fit_val = -1

  return fit_val


# 3- Trials Generation

def GenerateTrial():
  return 0


# 4- Population Generation

def GeneratePopulation(pop_size,pop_dim):

    # Population size is half of swarm size
    init_pop = pop_size

    # Initialize population list
    pop = []

    # Iterating from 1 to pop size to generate new solution in population
    i = 1
    while i<=init_pop:

        # flag to track weather currently generated solution is unique in population or not
        flag = False

        # 'x' is currently generated solution
        x = []
        x = np.random.randint(0,2,size=pop_dim)
        x = x.tolist()

        # Compute length of population to compare currently generated solution with every other solution in population to ensure every solution is unique
        length = len(pop)
        # Ensure every solution in population is unique means no two same initial solution

        # if length is > 0, means there is already solution generated in previous iteration
        if length > 0:

            # iterate every solution in population and compare it with currently generated solution to ensure unique solution
            for k in range(length):
                if x==pop[k]:
                    # if current solution is same as any other solution in population mark flag as true
                    flag = True
                    break

        # if flag is true means current solution is not unique so we will continue with same iteration number to again generate the solution
        if flag == True:
            continue
        # if flag is still false means current solution is unique which means append it into population list and increase iterartion number
        else:
            pop.append(x)
            i+= 1
    # convert population list into numpy array
    pop = np.array(pop)

    # calculate objective and fitness values for every solution in population
    obj_vals = []
    fit_vals = []
    trials = []
    for i in range(init_pop):
      obj_vals.append(ObjectiveValue(pop[i]))
      fit_vals.append(FitnessValue(obj_vals[i]))
      trials.append(GenerateTrial())

    # return population
    return (pop,obj_vals,fit_vals,trials)


# 5- Calculate Probablities

def Probablity(fit_val,max_fit):
  prob = ((0.9) * (fit_val/max_fit)) + (0.1)
  return prob


# 6- Generate New Solution

def GenerateNewSolution(primary,partner,pop_dim):

  index = random.randint(0,pop_dim-1)
  new_value = primary[index] + (np.random.uniform(-1,1))*(primary[index] - partner[index])

  if new_value < 0:
    new_value = 0

  elif new_value > 1:
    new_value = 1

  elif new_value > 0 and new_value < 1:
    if new_value < 0.5:
      new_value = 0
    else:
      new_value = 1

  primary[index] = new_value

  new_obj_val = ObjectiveValue(primary)
  new_fit_val = FitnessValue(new_obj_val)


  return (primary,new_obj_val,new_fit_val)


# A- Employed Bee Phase

def EmployedBees(pop,pop_dim,pop_size,obj_vals,fit_vals,trials):

    # print('Entered Employeed Bee',pop)

    for i in range(pop_size):

        primary = pop[i].copy()
        old_obj_val = obj_vals[i]
        old_fit_val = fit_vals[i]

        new_pop = np.delete(pop,i,axis=0)
        new_pop_size = pop_size - 1
        choosen = random.randint(0,new_pop_size-1)
        partner = new_pop[choosen]

        new_sol,new_obj_val,new_fit_val = GenerateNewSolution(primary,partner,pop_dim)
        # print('New Sol----------',new_sol)
        # print(new_obj_val)
        # print(old_obj_val)
        # print('Old sol-----------',pop[i])

        if new_fit_val > old_fit_val:
            # print('Goes in employeed if')
            pop[i] = new_sol
            obj_vals[i] = new_obj_val
            fit_vals[i] = new_fit_val
            trials[i] = 0

        else:
            # print('Goes in employed else')
            trials[i] = trials[i] + 1

        # print(pop)
        # print('----------------------------------------------------------------------------------------------------------------')


    return (pop,obj_vals,fit_vals,trials)


# B- Onlooker Bee Phase

def OnlookerBees(pop,pop_dim,pop_size,obj_vals,fit_vals,trials):

  probs = []
  max_fit = max(fit_vals)
  for i in range(pop_size):
    probs.append(Probablity(fit_vals[i],max_fit))

  updated_sol = 0
  n = 0

  while updated_sol < pop_size:
    primary = pop[n].copy()
    old_obj_val = obj_vals[n]
    old_fit_val = fit_vals[n]

    r = random.random()

    if r < probs[n]:
        new_pop = np.delete(pop,n,axis=0)
        new_pop_size = pop_size - 1
        choosen = random.randint(0,new_pop_size-1)
        partner = new_pop[choosen]

        new_sol,new_obj_val,new_fit_val = GenerateNewSolution(primary,partner,pop_dim)
        new_obj_val = ObjectiveValue(new_sol)
        new_fit_val = FitnessValue(new_obj_val)

        if new_fit_val > old_fit_val:
            # print('Goes in onlooker if')
            pop[n] = new_sol
            obj_vals[n] = new_obj_val
            fit_vals[n] = new_fit_val
            trials[n] = 0

        else:
            # print('Goes in onlooker else')
            trials[n] = trials[n] + 1


        updated_sol = updated_sol + 1

    n = n + 1
    if n == pop_size:
      n = 0

  return (pop,obj_vals,fit_vals,trials)


# C- Scout Phase

def Scout(pop,pop_dim,pop_size,obj_vals,fit_vals,trials,limit):

  for i in range(pop_size):

    if trials[i] > limit:

        primary = pop[i].copy()

        new_pop = np.delete(pop,i,axis=0)
        new_pop_size = pop_size - 1
        choosen = random.randint(0,new_pop_size-1)

        partner = new_pop[choosen]

        new_sol,new_obj_val,new_fit_val = GenerateNewSolution(primary,partner,pop_dim)

        pop[i] = new_sol
        obj_vals[i] = new_obj_val
        fit_vals[i] = new_fit_val
        trials[i] = 0

  return (pop,obj_vals,fit_vals,trials)

#---------------------------------------------------------------------------------------------------------------------------------------------------------
#*********************************************************************************************************************************************************
#---------------------------------------------------------------------------------------------------------------------------------------------------------
print('----------------------------------------------------------ABC Algo-----------------------------------------------------')
pop_size = int(input('Enter Population Size: '))
pop_dim = int(input('Enter number of features in dataset (11 in our dataset): '))
iterations = int(input('Enter number of iterations: '))
runs = int(input('Enter no of runs (usually 30): '))

all_fit_vals = []

runs_best_obj_vals = []
runs_best_sols = []

runs_time = []

run_count = 1
while run_count <= runs:

  # Get the current time
  start_time = datetime.datetime.now()

  # Generate initial population
  pop,obj_vals,fit_vals,trials = GeneratePopulation(pop_size,pop_dim)

  iteration_best_obj_vals = []
  iteration_best_sols = []

  iteration_count = 1
  while iteration_count <= iterations:

    # Employed Bees Phase
    pop,obj_vals,fit_vals,trials = EmployedBees(pop,pop_dim,pop_size,obj_vals,fit_vals,trials)

    # Onlooker Bees Phase
    pop,obj_vals,fit_vals,trials = OnlookerBees(pop,pop_dim,pop_size,obj_vals,fit_vals,trials)


    # Store iteration best obj val and solution
    best_obj_val = max(fit_vals)
    best_obj_val_index = fit_vals.index(best_obj_val)
    best_sol = pop[best_obj_val_index]

    iteration_best_obj_vals.append(best_obj_val)
    iteration_best_sols.append(best_sol)


    # Scout Phase
    limit = pop_size * pop_dim
    pop,obj_vals,fit_vals,trials = Scout(pop,pop_dim,pop_size,obj_vals,fit_vals,trials,limit)

    iteration_count = iteration_count + 1


  # Get the current time again
  end_time = datetime.datetime.now()
  # Calculate the difference between the two times
  time_difference = end_time - start_time
  runs_time.append(time_difference)

  # Store cycle best obj val and solution
  run_best_obj_val = max(iteration_best_obj_vals)
  run_best_obj_val_index = iteration_best_obj_vals.index(run_best_obj_val)
  run_best_sol = iteration_best_sols[run_best_obj_val_index]

  runs_best_obj_vals.append(run_best_obj_val)
  runs_best_sols.append(run_best_sol)


  # Store all best fitness values for current cycle to plot graph
  all_fit_vals.append(iteration_best_obj_vals)


  run_count = run_count + 1

max_obj_val = max(runs_best_obj_vals)
max_obj_val_index = runs_best_obj_vals.index(max_obj_val)
max_sol = runs_best_sols[max_obj_val_index]

min_obj_val = min(runs_best_obj_vals)
min_obj_val_index = runs_best_obj_vals.index(min_obj_val)
min_sol = runs_best_sols[min_obj_val_index]





print('After',runs,'repeated cycles for ',pop_size,'population size the best and worst recall value with its solution is given below')

print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Maximum Recall Value ---> ( ', max_obj_val, ' )')
print('---------------------------Solution with Maximum Recall Value ---> ( ', max_sol, ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Minimum Recall Value ---> ( ', min_obj_val, ' )')
print('---------------------------Solution with Minimum Recall Value ---> ( ', min_sol, ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Average Recall Value ---> ( ', np.mean(runs_best_obj_vals), ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Standard Deviation = ( ',np.std(runs_best_obj_vals), ' )')
print('---------------------------------------------------------------------------------------------------------------------')




# Create runs and iterations lists
runs_list = [i+1 for i in range(runs)]
iteration_list = [i+1 for i in range(iterations)]

# Create figure and subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 14))

# Plot Graph 1 in ax1
for i in range(len(all_fit_vals)):
    lw = 10 - 9 * i / len(all_fit_vals)
    sns.lineplot(x=iteration_list, y=all_fit_vals[i], label='Run'+str(i+1), linewidth=lw, ax=ax1)
ax1.set_xlabel('Iteration Number')
ax1.set_ylabel('Fitness Value')
ax1.set_title('Best Fitness Value Vs Iteration Number')
ax1.legend(loc='upper right', bbox_to_anchor=(1.5, 1), ncol=2)

# Convert runs time into seconds
for i in range(len(runs_time)):
    runs_time[i] = runs_time[i].total_seconds()

# Calculate average, maximum, and minimum time
average_time = sum(runs_time) / len(runs_time)
maximum_time = max(runs_time)
minimum_time = min(runs_time)

# Plot Graph 2 in ax2
ax2.plot(runs_list, runs_time, marker='*', color='maroon')
ax2.axhline(y=average_time, color='yellow', linestyle='--', label=f'Average = {round(average_time, 3)} seconds')
ax2.axhline(y=maximum_time, color='red', linestyle='--', label=f'Maximum = {round(maximum_time, 3)} seconds')
ax2.axhline(y=minimum_time, color='green', linestyle='--', label=f'Minimum = {round(minimum_time, 3)} seconds')
ax2.set_xlabel('Run Number')
ax2.set_ylabel('Time in Seconds')
ax2.set_title('Time Required For Every Run In Seconds')
ax2.legend(loc='upper right', bbox_to_anchor=(1.55, 1))

# Adjust spacing and show the plot
plt.subplots_adjust(hspace=0.5)
plt.show()

