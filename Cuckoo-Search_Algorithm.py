# -*- coding: utf-8 -*-
"""Cukoo_Search.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NiJEdatM00M4xAeYYWi2jrBHC1zH931M
"""

# Import Libraries
import math
import random
import numpy as np
import datetime
import time
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import pandas as pd
import random

# -------------------------------------------------------------------------------------------------

# Uncomment the performance measure which you want to computer and make sure to comment out other three

from accuracy import Model
# from precision import Model
# from recall import Model
# from f1_score import Model


# --------------------------------------------------------------------------------------------------------------


# 1- Find Objective function value for each solution in population

def ObjectiveValue(sol):

  result = Model(sol)
  return result


# 2- Find Fitness Value for every solution using objective function values

def FitnessValue(obj_val):

  if obj_val >= 0:
    fit_val = obj_val
  else:
    fit_val = -1

  return fit_val


# 3- Population Generation

def GeneratePopulation(pop_size,pop_dim):

    # Initialize population list
    pop = []

    # Iterating from 1 to pop size to generate new solution in population
    i = 1
    while i<=pop_size:

        # flag to track weather currently generated solution is unique in population or not
        flag = False

        # 'x' is currently generated solution
        x = []
        x = np.random.randint(0,2,size=pop_dim)
        x = x.tolist()

        # Compute length of population to compare currently generated solution with every other solution in population to ensure every solution is unique
        length = len(pop)
        # Ensure every solution in population is unique means no two same initial solution

        # if length is > 0, means there is already solution generated in previous iteration
        if length > 0:

            # iterate every solution in population and compare it with currently generated solution to ensure unique solution
            for k in range(length):
                if x==pop[k]:
                    # if current solution is same as any other solution in population mark flag as true
                    flag = True
                    break

        # if flag is true means current solution is not unique so we will continue with same iteration number to again generate the solution
        if flag == True:
            continue
        # if flag is still false means current solution is unique which means append it into population list and increase iterartion number
        else:
            pop.append(x)
            i+= 1
    # convert population list into numpy array
    pop = np.array(pop)

    # calculate objective and fitness values for every solution in population
    obj_vals = []
    fit_vals = []
    best = []
    for i in range(pop_size):
      obj_vals.append(ObjectiveValue(pop[i]))
      fit_vals.append(FitnessValue(obj_vals[i]))

    best_fit_val = max(fit_vals)
    best_sol = pop[fit_vals.index(best_fit_val)]

    best.append(best_fit_val)
    best.append(best_sol)

    return (pop,obj_vals,fit_vals,best)


# 4- Update Best Solution

def UpdateBestSolution(pop,obj_vals,fit_vals,best):

  current_best_fit_val = max(fit_vals)
  if current_best_fit_val > best[0]:
    best[0] = current_best_fit_val
    best[1] = pop[fit_vals.index(current_best_fit_val)]

  return best


# 4- Modify Solution

def ModifySolution(pop,obj_vals,fit_vals,alpha,best):
  for i in range(len(pop)):

    diff_indexes = []

    if not (np.array_equal(pop[i],best[1])):
      for j in range(len(pop[i])):
        if pop[i][j] != best[1][j]:
          diff_indexes.append(j)

    if len(diff_indexes) < alpha:
      alpha = len(diff_indexes)

    choosen_indexes = []
    l = 1
    while l <= alpha:
      index = random.choice(diff_indexes)
      if index not in choosen_indexes:
        choosen_indexes.append(index)
        l += 1

    for choosen_index in choosen_indexes:
      pop[i][choosen_index] = best[1][choosen_index]

    new_obj_val = ObjectiveValue(pop[i])
    new_fit_val = FitnessValue(new_obj_val)

    obj_vals[i] = new_obj_val
    fit_vals[i] = new_fit_val

  return(pop,obj_vals,fit_vals)


# 5- Update Population
def UpdatePopulation(pop,obj_vals,fit_vals,Pa):

  no_of_new_sols = round( (len(pop)) * (Pa/100) )
  index_of_solution_to_delete = []

  i = 0
  while i < (no_of_new_sols):
    x = random.randint(0,len(pop)-1)
    if x not in (index_of_solution_to_delete):
      index_of_solution_to_delete.append(x)
      i+= 1
  del(i)
  index_of_solution_to_delete = sorted(index_of_solution_to_delete, reverse = True)

  new_sols,new_sols_obj_vals,new_sols_fit_vals,new_sols_best = GeneratePopulation(no_of_new_sols,len(pop[0]))

  for index in index_of_solution_to_delete:
    pop = np.delete(pop,index,axis=0)
    del(obj_vals[index])
    del(fit_vals[index])

  for new_sol,new_obj_val,new_fit_val in zip(new_sols,new_sols_obj_vals,new_sols_fit_vals):
    pop = np.vstack((pop,new_sol))
    obj_vals.append(new_obj_val)
    fit_vals.append(new_fit_val)

  return (pop,obj_vals,fit_vals)




# --------------------------------------------------------------------------------------------------------------------------------

print('----------------------------------------------------------Cukoo Search-----------------------------------------------------')
pop_size = int(input('Enter Population Size: '))
pop_dim = int(input('Enter number of features in dataset (11 in our dataset): '))
alpha = int(input('Enter value of Step Size alpha: '))
Pa = int(input("Enter value of Switching Probablity 'Pa' : "))
iterations = int(input('Enter number of iterations: '))
runs = int(input('Enter no of runs (usually 30): '))

all_fit_vals = []

runs_time = []
runs_best_obj_vals = []
runs_best_sols = []

run_count = 1
while run_count <= runs:

  iteration_best_obj_vals = []
  iteration_best_sols = []

  # Get the current time
  start_time = datetime.datetime.now()

  # Generate Initial Population
  pop,obj_vals,fit_vals,best = GeneratePopulation(pop_size,pop_dim)

  iteration_count = 1
  while iteration_count <= iterations:

    # Modify All Solutions To Bring It CLoser To Best Solution Obtained Till Now
    pop,obj_vals,fit_vals = ModifySolution(pop,obj_vals,fit_vals,alpha,best)

    # Update Population By Replacing Some Current Solution With New Genrated Solutions
    pop,obj_vals,fit_vals = UpdatePopulation(pop,obj_vals,fit_vals,Pa)

    # Update Best Solution
    best = UpdateBestSolution(pop,obj_vals,fit_vals,best)

    # Store Iteration Best Objective Value and Best Solution
    iteration_best_obj_vals.append(max(obj_vals))
    iteration_best_sols.append(pop[obj_vals.index(max(obj_vals))])

    iteration_count += 1

  # Get the current time again
  end_time = datetime.datetime.now()
  # Calculate the difference between the two times
  time_difference = end_time - start_time
  runs_time.append(time_difference)

  # Store Run Best Objective Value and Best Solution
  runs_best_obj_vals.append(max(iteration_best_obj_vals))
  runs_best_sols.append(iteration_best_sols[iteration_best_obj_vals.index(max(iteration_best_obj_vals))])

  # Store All Best Fitness Values Of This Run To Plot Graph
  all_fit_vals.append(iteration_best_obj_vals)

  run_count += 1

max_obj_val = max(runs_best_obj_vals)
max_sol = runs_best_sols[runs_best_obj_vals.index(max_obj_val)]

min_obj_val = min(runs_best_obj_vals)
min_sol = runs_best_sols[runs_best_obj_vals.index(min_obj_val)]


print('After',runs,'repeated cycles for ',pop_size,'population size the best and worst accuracy value with its solution is given below')

print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Maximum Value ---> ( ', max_obj_val, ' )')
print('---------------------------Solution with Maximum Value ---> ( ', max_sol, ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Minimum Value ---> ( ', min_obj_val, ' )')
print('---------------------------Solution with Minimum Value ---> ( ', min_sol, ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Average Value ---> ( ', np.mean(runs_best_obj_vals), ' )')
print('---------------------------------------------------------------------------------------------------------------------')
print('---------------------------Standard Deviation = ( ',np.std(runs_best_obj_vals), ' )')
print('---------------------------------------------------------------------------------------------------------------------')



# Create runs and iterations lists
runs_list = [i+1 for i in range(runs)]
iteration_list = [i+1 for i in range(iterations)]

# Create figure and subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 14))

# Plot Graph 1 in ax1
for i in range(len(all_fit_vals)):
    lw = 10 - 9 * i / len(all_fit_vals)
    sns.lineplot(x=iteration_list, y=all_fit_vals[i], label='Run'+str(i+1), linewidth=lw, ax=ax1)
ax1.set_xlabel('Iteration Number')
ax1.set_ylabel('Fitness Value')
ax1.set_title('Best Fitness Value Vs Iteration Number')
ax1.legend(loc='upper right', bbox_to_anchor=(1.5, 1), ncol=2)

# Convert runs time into seconds
for i in range(len(runs_time)):
    runs_time[i] = runs_time[i].total_seconds()

# Calculate average, maximum, and minimum time
average_time = sum(runs_time) / len(runs_time)
maximum_time = max(runs_time)
minimum_time = min(runs_time)

# Plot Graph 2 in ax2
ax2.plot(runs_list, runs_time, marker='*', color='maroon')
ax2.axhline(y=average_time, color='yellow', linestyle='--', label=f'Average = {round(average_time, 3)} seconds')
ax2.axhline(y=maximum_time, color='red', linestyle='--', label=f'Maximum = {round(maximum_time, 3)} seconds')
ax2.axhline(y=minimum_time, color='green', linestyle='--', label=f'Minimum = {round(minimum_time, 3)} seconds')
ax2.set_xlabel('Run Number')
ax2.set_ylabel('Time in Seconds')
ax2.set_title('Time Required For Every Run In Seconds')
ax2.legend(loc='upper right', bbox_to_anchor=(1.55, 1))

# Adjust spacing and show the plot
plt.subplots_adjust(hspace=0.5)
plt.show()



